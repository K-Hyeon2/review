# 1103 월

</br>
</br>
</br>

## 가상환경 설정

<code>
<pre>

!pip install uv                 --uv 다운로드
!uv venv .venv                  --가상환경 만들기 (기존 파이썬 버전 설치)
!uv pip install pandas          --pandas 설치
!uv pip install ipykernel       --ipykernel 설치
!uv pip install matplotlib      --matplotlib 설치
!uv pip install scikit-learn    --scikit-learn 설치

#Ctrl + Shift + P               --명령어창 가상환경 선택
#가상환경 설정                   --사용할 가상환경 설정

##가상환경 설치 후 기본설정##
##matplotlib 설정##
font.family : malgun gothic
axex.unicode_minus : False

</pre>
</code>



</br>
</br>
</br>


## 넘파이 (Numpy)

>백터, 행렬 연산을 위한 수치해석용 라이브러리

- 강력한 다차원 배열 지원
- 빠른 수치 계산 가능
- 다양한 함수를 제공
- 선형대수, 난수생성, 푸리 변환가능

</br>

#### 넘파이 데이터 구조
- 스칼라:   값 하나 (0차원)
- 벡터:     여러개의 값 모음 (1차원)
- 행렬:     백터들의 모음 (2차원)
- 텐서:     N개의 방향 값 관리 (N차원)

</br>

#### 넘파이 용어 설명
- 축:   값의 나열 방향 (N차원=N개의 축)
- 랭크: 데이터 집합에서 축의 개수, 차원이라고도 함
- 형태: 각 축 별 데이터 개수 (형상)
- 크기: 배열 내 원소의 총 개수

</br>

#### 넘파이 배열
- 같은 타입의 값들만 가질 수 있다
- 축별 데이터늬 개수는 모두 **동일하다**
- 백터 연산과 브로드 캐스팅 기능 제공
- Vevtor차원:   원소의 개수
- 넘파이차원:   축의 개수



</br>
</br>
</br>



## 다양한 함수

</br>

#### array(iterable [,dytpe]), 배열 생성

<code>
<pre>
import numpy as np

a1 = np.array([1, 10, 2, 30, 100])
print(type(a1))
#array([1   10   2   30   100])


print("배열 형태(-축별 크기. 튜플):", a1.shape)
#배열 형태(-축별 크기. 튜플): (5,)

print("랭크(차원):", a1.ndim)
#랭크(차원): 1

print("총 원소 개수:", a1.size)
#총 원소 개수: 5

print("데이터타입:", a1.dtype)
#데이터타입: int64
</pre>
</code>

</br>

#### 동일한 값들고 구성된 배열 생성

- zero(shape [, dtype]):    원소가 0으로만 채워진 배열 생성
- ones(shape [, dtype]):    원소가 1로만 채워진 배열 생성    
- full(shape, fill_value [, dtype]):    원소가 fill_value로만 채워진 배열
- z,o,f_like(shape [, dtype]):          호출 배열과 같은 배열을 가진 배열


</br>
</br>
</br>


#### 특정 범위 내 동일한 간격의 값들로 구성된 배열 생성

>arange(start, stop, step, dtype)

<code>
<pre>
a20 = np.arange(1, 11, 2)  # 인수: 3  (start, stop(불포함), step)
#array([1, 3, 5, 7, 9])


a21 = np.arange(1, 10)   # 인수: 2 (start, stop, step(생략: 1))
#array([1, 2, 3, 4, 5, 6, 7, 8, 9])


a22 = np.arange(10)    # 인수: 1 (**stop**)  start(생략: 0), step(생략: 1)
#array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
</pre>
</code>

</br>

>linspace(start, stop, num=50, endpoint=True, retstep=False, dytpe=None)

- num:      간격의 값
- endpoint: stop값을 포함시킬지 여부
- retstep:  tuple반환

<code>
<pre>
a31 = np.linspace(1, 20, num=5) # 개수 지정
#array([ 1.  ,  5.75, 10.5 , 15.25, 20.  ])


np.linspace(1, 20, num=5, 
            endpoint=False)
#array([ 1. ,  4.8,  8.6, 12.4, 16.2])
</pre>
</code>


</br>
</br>
</br>


#### 난수를 원소로 하는 ndarray 생성

>np.random.seed(시드값)
- 난수 발생 알고리즘이 사용할 시드값 설정
- 시드값을 설정하면 항상 일정한 순서의 난수가 발생
- 시드값을 고정시키면 항상 시작 값이 같고 순서대로 제공된다 (재현성)

- 인공지능의 점수 = 난수 x 알고리즘
- 어떤 난수를 넣을 지 모르니 찾는 과정


<code>
<pre>

</pre>
</code>


</br>
</br>
</br>

#### 정규분포
>np.random.normal(loc=0.0, scale=1.0, size=None)

- loc:      평균
- scale:    표준편차
- size:     개수 및 N차원


<code>
<pre>
np.random.normal()  
#한개, 평균: 0, 표준편차: 1 (표준정규분포)


np.random.normal(size=5) 
#1차원 - 5개


np.random.normal(size=(2, 5)) 
#2차원 - (2, 5)


r = np.random.normal(
    loc=10,   #평균
    scale=2,  #표준편차
    size=100  #개수/shape
)
</pre>
</code>


</br>


>np.random.randint(low, high=None, size=None, dtype='int32')
- low~high 사이 정수 리턴 (high 포함 안됨)
- high 생략시 0~low사이 정수 리턴
- size는 배열의 크기
- dtype은 원소의 타입


<code>
<pre>
np.random.randint(10, 20)  
#10 ~ 20(불포함) 사이 랜덤 정수. size 생략: 1개

np.random.randint(5) 
#0 ~ 5(불포함) 사이 랜덤정수. (start 생략: 0)

np.random.randint(10, 100, size=(3, 10))
</pre>
</code>

</br>

>np.random.choice(a, size=None, replace=True, p=None)

- 표본추출 메소드
- a:        샘플링 대상, 1차원 배열 또는 정수
- size:     샘플 개수
- replace:  True:복원추출 False:비복원추출
- p:        샘플링 할 대상 값들이 추출될 확률 지정한 배


<code>
<pre>

l = [1, 2, 3, 4, 5, 6, 7, 8, 9]

np.random.choice(l, size=5)   
#모집단(sampling대상) 에서 n(5)개 sample(표본) 추출


np.random.choice(l, size=5, replace=False)  
#중복되지 않게 추출. (비복원추출)


np.random.choice(l, size=100) 
#복원 추출이므로 모집단 보다 많은 개수의 sample 추출가능


r = np.random.choice([True, False], size=10, p=[0.1, 0.9])
#True 10%, False 90% 확률도 등장
</pre>
</code>


</br>
</br>
</br>


#### ndarray 배열 파일에 저장 및 불러오기

>1파일 1배열 저장: np.save("파일경로", 배열) 확장자로 npy사용

</br>

>1파일 N배열 저장: np.savez("파일경로", 이름=배열, 이름=배열) 확장자로 npz사용

</br>

>np.load("파일경로") 확장자 상관없음

</br>
</br>

#### 텍스트 파일로 저장 및 불러오기

>np.savetext("파일경로", 배열 [, delimiter="공백"])

</br>

>np.loadtxt("파일경로" [,dtype=float, delimiter=공백])


</br>
</br>
</br>


#### 배열 인덱싱, 팬시, 슬라이싱, boolean, 비교연산자는 중복 내용이라 생략


</br>
</br>
</br>


## np.where()

>Trun의 index 조회

<code>
<pre>

r1 = np.where([True, False, True])  # True의 index를 반환 -> tuple(배열)
r1 = np.where(
    [
        [True, False, False],
        [True, False, True]
    ]
) 
#(array([0, 1, 1]), array([0, 0, 2]))
#(0, 0), (1, 0,), (1, 2)에 True값 존재



r2 = np.where(b < 100)
#b배열 중 100미만의 수 조회
#3개의 Series가 위와 같이True의 좌표를 알려줌

</pre>
</code>

</br>

>np.any(boolean 배열)
- 배열 내 True가 하나라도 있으면 True 반환
- 배열 내 특정조건을 만족하는 값이 하나 있는지 확인용

</br>

>np.all(boolean 배열)
- 배열 내 모든 원소가 True면 True 반환
- 배열 내 모든 원소가 특정조건을 만족하는지 확인용


</br>
</br>
</br>


## 배열의 형태 변경

>배열의 **원소 개수를 유지**한 상태에서 shape 변경
>(16, ) - (4, 4) - (2, 2, 4) - (4, 4, 1) - (1, 16)
>단순히 차원만 늘려줌

</br>
</br>

#### reshape()를 이용한 차원 변경

>numpy.reshape(a, newshape)     #모든 형태 처리
>ndarray.reshape(newshape)      #ndarray만 처리

<code>
<pre>

r1 = x.reshape(2, 10)       #(2, 10)
r2 = x.reshape(2, 2, 5)     #(2, 2, 5) 
r3 = x.reshape(4, 5)        #(4, 5)
r4 = x.reshape(1, 1, 1, 20) #(1, 1, 1, 20)
r5 = np.reshape(x, (2, 10)) #(2, 10)

#차원의 수나 배열은 달라졌지만 원소 개수는 똑같

r5 = x.reshape(10, -1)  
#-1로 지정한 축은 계산해서 결정한다. 
#변경 할 shape중 하나는 -1로 지정할 수 있다.

</pre>
</code>


</br>
</br>

#### 차원 늘리기 및 줄이기

</br>

>ndarry[np.newxais, ...]
>np.expand_ndim(대상배열, axis=늘릴 축)
</br>



<code>
<pre>
x = np.arange(30)
y = x.reshape(1, -1)
y.shape                 #(1, 30)


x2 = np.arange(30).reshape(3, 5, 2)
y2 = x2.reshape(1, x2.shape[0], x2.shape[1], -1)
y2.shape                #(1, 3, 5, 2)
##reshape로도 늘릴 수는 있지만 다소 복잡하다


r1 = x[np.newaxis, ...]     #(1, 30)
r2 = x[..., np.newaxis]     #(30, 1)
#앞, 뒤로 np.newaxis를 이용하여 더미 축 생성(여러 개 가능)


x2.shape                             #(3, 5, 2)
r21 = np.expand_dims(x2, axis=-1)    #(3, 5, 2, 1)
#index -1(맨 뒤)에 1의 더미 축 생성
r22 = np.expand_dims(x2, axis=1)     #(3, 1, 5, 2)
#index 1(두 번째)에 1의 더미 축 생성


r30 = np.array([20, 39, 20, 39]).reshape(1, 2, 1, 2, 1, 1)
#(1, 2, 1, 2, 1, 1)
v3 = r30.squeeze()          #(2, 2) 모든 더미 축 제거
v4 = r30.squeeze(axis=2)    #(1, 2, 2, 1, 1) 2번 인덱스 더미 축만 제거
v5 = r30.squeeze(axis=(0, 2, 4))    #(2, 2, 1)
#여러 더미 축 제거 **list는 안됨, tuple로 지정**


x2.shape                     #(3, 5, 2)
x10 = x2.transpose(1, 2, 0)  #(5, 2, 3)
#1->5, 2->2, 0->3 인덱스 별 변환
</pre>
</code>