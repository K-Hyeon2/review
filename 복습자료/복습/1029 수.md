# 1029 수

</br>
</br>
</br>

## Query()를 이용한 boolean indexing

- 장점 : 편의성과 가독성이 좋다
- 단점 : 속도가 느리다 (체감할 정도로 느리지는 않다)

</br>

## Query 메소드 사용 연산자

#### 비교 연산자
>==, <, >, <=, >=, !=

</br>

#### 결측치 비교
>컬럼.isna(), isnull()
>컬럼.notna(), notnull

 </br>

 #### in 연산자
>in, ==
>not in, !=
>비교 대상값은 리스트에 넣는다

</br>

#### 문자열 부분 검색
> 컬럼명.str.contains(문자열):문자열을 포함하고 있는
> 컬럼명.str.startwith(문자열):문자열로 시작하는
> 컬럼명.str.endswith(문자열):문자열로 끝나는
> **문자열 부분검색할 때 결측치가 있으면 에러가 난다**
> 부분 검색하기 전 notnull()을 사용하는 것이 좋음

</br>
</br>
</br>

## 예시

<code>
<pre>

import pandas as pd
import numpy as np

data_dict = {
    "name": ["김영수", "박영희", "오준호", "조민경", "박영희", "김영수"],
    "age": [23, 17, 28, 31, 23, 17],
    "email": [
        "kys@gmail.com",
        "pyh@gmail.com",
        "ojh@daum.net",
        "cmk@naver.com",
        "pyh@daum.net",
        np.nan,
    ],
}
df = pd.DataFrame(data_dict)
df

</pre>
</code>

</br>
</br>
</br>

<code>
<pre>

#pandas 방식
df[df['age'] == 17]
#query 방식
df.query("age == 17")

#pandas 방식
df[(df['name'] == '박영희') & (df['age'] > 20)]
#query 방식
df.query('name' == '박영희 and age > 20)

#pandas 방식
df[df['age'].isin([17, 20, 23])]
#query 방식
df.query('age in [17, 20, 23]')

</pre>
</code>

>Query가 가독성이 좋다.
>주의해야할 구문을 예를 들면, **df.query("name == '김영수'")**
>위와 같이 큰 따옴표와 작은 따옴표 구분을 잘해야 한다.

</br>
</br>
</br>

## 정렬

>sort_index(axis=0, ascending=True, inplace=False)

</br>

- axis=0 : index 이름 기준 정렬(행) (default 값)
- axis=1 : column 이름 기준 정렬(열)
- acsending=True : 오름차순 (default 값)
- acsending=False : 내림차순
- inplace=True : 원본 변경
- inplace=False : 원본 변경 안함

</br>

<code>
<pre>

df.sort_index(axis=1)                   #컬럼 이름 기준으로 오름차순 정렬

df.sort_index(axis=1, ascending=False)  #컬럼 이름 기준으로 내림차순 정렬

df.sort_index()                         #행 이름 기준으로 오름차순 정

df.sort_index(ascending=False)          #행 이름 기준으로 내림차순 정

</pre>
</code>

</br>
</br>
</br>

## 특정 컬렴의 값을 기준으로 정렬

>sort_value(by, ascending, inplace)

</br>

- by : 정렬 기준 컬럼 이름을 문자열로 지정
- by : 여러 컬럼에 대해 정렬할 경우 리스트에 담아 전달
- ascending, inplace : 위 설명과 동일

</br>

<code>
<pre>

df.sort_values('director_name', ascending=False)        #director_name열을 오름차순으로 정렬

df.sort_values(by=["duration", "movie_facebook_likes"])[["duration", "movie_facebook_likes"]].head(5)
#duration, movie_facebook_likes열을 오름차순으로 정렬하고 duration, movie_facebook_likes열만 보고 5행만 출력

df['color'].value_counts().sort_values().plot(kind='bar');
#color열 호출 - color열의 value값 산출 - 오름차순으로 color의 value값 정렬 - bar차트로 출


</pre>
</code>


</br>
</br>
</br>


## aggregate 또는 agg

<code>
<pre>
#기본 예시
df['DEP_DELAY'].aggregate(['min','max'])
df['DEP_DELAY'].agg(['min','max'])          #둘 다 똑같음

d = {
    "DEP_DELAY" : "sum",    #"DEP_DELAY" : sum 값 반환
    "ARR_DELAY" : "count",  #"ARR_DELAY" : count 값 반환
    "DIST" : ["min", "max"] #"DIST" : min, max 값 반환
}

df.agg(d)                   #agg를 이용하여 호출



#함수를 만들어서 사용해보기
def max_min_diff(series):
    return series.max() - series.min()

df['DEP_DELAY'].agg(['max', 'min', max_min_diff])
</pre>
<code>

</br>

- aggregate를 간소화 하여 agg로 표현해도 된다
- 'DEP_DELAY' 열의 min값과 max값을 동시에 반환해준다
- 통계량을 다양한 형태로 모아서 한 번에 확인할 때 사용한다


</br>
</br>
</br>


## Groupby

>df.groupby('그룹으로 묶을 기준 컬럼')['집계할 컬럼'].집계함수()

</br>

>df.groupby('AIRLINE')['DEP_DELAY'].mean()

- 'AIRLINE' : 항공사를 그룹으로 묶음
- 'DEP_DELAY' : 딜레이 시간을 호출
- 'mean()' : 딜레이 시간의 평균 시간을 집계
  
  >항공사별 평균 딜레이 시간 반환

</br>
</br>
</br>

## Pivot_tavle()

>groupby()를 이용한 집계와 같은데 여러개 칼럼을 기준으로 groupby를 할 경우 집계 결과를 읽는 것이 편하다.

</br>


<code>
<pre>

df.pivot_table(
    index="AIRLINE",        #groupby로 묶을 컴럼중 index에 놓을 컬럼명
    columns="ORG_AIR",      #groupby로 묶을 컴럼중 column에 놓을 컬럼명
    values="CANCELLED",     #집계 대상 컬럼
    aggfunc='sum',          #집계 함수, (default:"mean()") 
    margins=True,           #index, column, 전체별 집계 결과 추가
    margins_name='총계',    #margins의 label을 지정
    fill_value=0            #결측치 (NaN-group이 없는 cell) 대신 넣을 값
)

</pre>
</code>


</br>
</br>
</br>


## 연속형을 범주형으로 변환

>pd.cut(x, bins, right=True, labels=None)

- x : 범주형으로 바꿀 대상 (Series, 리스트, ndarry)
- bins : 범주로 나눌때의 기준값들을 리스트로 묶음
- right : 구간경계의 오른쪽(True-default), 왼쪽(False)을 포함할지
- labels : 각 구간의 label을 리스트로 전달


<code>
<pre>

import numpy as np
np.random.seed(0)
d = {
    "age": np.random.randint(1, 100, size=30),
    "tall": np.round(np.random.normal(170, 10, size=30), 2),
}
df = pd.DataFrame(d)
df

#age:1~100살까지 30개 생성
#tall:170을 기준으로 표준편차 10으로 소수점 2자리 실수30개 생성 



나이대 = pd.cut(
    df['age'],    # 범주형으로 만들 수치형값들
    bins=3,       # 몇개의 범주로 나눌지. (범위로 등분)  
    right=False   #default: True -> 등분 범위에 어느쪽을 포함시킬지.  # True: 끝 포함, False: 시작 포함
)


나이대.value_counts()

</pre>
</code>


</br>
</br>
</br>


## apply()

>DataFrame.apply(함수, axis=0, args=(), **kwarg)
- 함수 : DataFrame의 행, 열들을 전달하는 함수
- axis : 0 - 열을 전달, 1 - 행을 전달 (기본값 0)
- args : 함수에 행열 이 외에 전달할 매개변수를 위치기반 튜플로 전달
- **kwarg : 함수에 행열 이 외에 전달할 매개변수를 키워드 인자로 전달

</br>

>Series.apply(함수, args=(), **kwarg)
- axis외 DataFrame랑 똑같다

</br>

<code>
<pre>

df = pd.read_csv("data/flights.csv")
#data 폴더 안의 flights.csv 파일을 불러오기


df['WEEKDAY'].value_counts().sort_index()
#요일별 개수 호출 - 요일별로 오름차순


#일괄처리 함수 (정수->요일 문자열로 변환)

import numpy as np

#apply()에 넣어줄 함수 구문 : 매개변수 1개 이상
#첫 번째 매개변수는 DataFrame/Series의 원소를 받는다

def convert_weekday(value):
    if pd.isna(value):      #결측치가 있는 경우 결측치로 리턴
        return np.nan
    return "월화수목금토일"[int(value)-1]+"요일"  

    #indexing에서 index는 정수만 가능. 만약 컬럼에 결측치가 있으면
    #그 컬럼(Series)의 타입은 float이 된다.
    #그래서 결측치가 있는 행에 대해 이 함수가 적용될 경우 Exception이 발생한다


df['WEEKDAY'].apply(convert_weekday)
#

</pre>
</code>

