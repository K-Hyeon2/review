# 1030 목

</br>
</br>
</br>

## DataFrame 합치기

>두 개 이상의 DataFrame을 합쳐 하나의 DataFrame으로 만든다.

</br>

#### 수직결합
- 단순결합 : **같은 컬럼끼리** 수직으로 합친다. 데이터의 양이 많아 나누고 다시 합칠 때 주로 사용

</br>

#### 수평결합
- JOIN : **같은 INDEX끼리** 하나로 합쳐 조회
- 단순결합 : 위와 같이 데이터 양이 많아 나누고 다시 합칠 때 사용

</br>
</br>
</br>

## 예시

<code>
<pre>

from glob import glob           #glob:특정 디렉토리의 파일을 한 번에 불러올 때 사용
import pandas as pd             #glob:디렉토리의 경로를 반환해줌
import numpy as np              #recursive=True

ex> glob("data/s*.csv")
    [data\\stocks_2016.csv,
    data\\stocks_2017.csv,
    data\\stocks_2018.csv,
    data\\stocks_2019.csv]      #해당 디렉토리의 모든 파일 경로를 리스트로 반환

    glob("./**/*.csv")
    #현재 있는 디렉토리에서 모든 하위 디렉토리를 선택
    #모든 하위 디렉토리 안의 .csv파일 경로를 리스트로 리턴



file_names = glob("data/s*.csv")

stock_2016, stock_2017, stock_2018, stock_info = [pd.read_csv(file_name) for file_name in file_names]



</pre>
</code>


</br>
</br>
</br>

#### concat()

>수직, 수평 결합 모두 지원한다 (axis 활용)
>concat([df1, df2], axis=1, join='outer')
- 수직결합 : **컬럼명이 같은** 열끼리 합친다 (full outer join개념)
- 수평결합 : **index명이 같은** 행끼리 합친다 (full outer join개념)
- join : 'outer'(기본값) 모두 합침, 'inner' 동일한 index or column명 합침
- keys : 각 DataFrame을 구분할 수 있는 index 지

</br>

<code>
<pre>

result = pd.concat([stock_2016, stock_2017])  # axis=0 (default: 0 - 수직) # 열이름이 같은 열끼리 합친다.
result.reset_index()                #기존 인덱스를 살리고 새로운 인덱스를 순서대로 생성
result.reset_index(drop=True)       #기존 인덱스를 지우고 새로운 인덱스를 순서대로 생성


pd.concat([stock_2016, stock_2017], axis=1)  # 행이름이 같은 행끼리 합친다.
#없을 경우 결측치로 반환
pd.concat([stock_2016, stock_2017], axis=1, join="inner") # 같은 인덱스끼리만 합침


pd.concat([stock_2016, stock_2017], axis=1)
#행이름이 같은 행끼리 합친다.
#없는 행은 결측치로 반환한다.
pd.concat([stock_2016, stock_2017], axis=1, join="inner")
#같은 인덱스끼리만 합침
#겹치지 않는 인덱스는 없어짐





result3 = pd.concat(
    [stock_2016, stock_2017, stock_2018], 
    keys=['2016년', '2017년', '2018년'] # 각 DataFrame을 구분할 수있는 index를 지정. 
)

#같은 열 기준으로 수직으로 합침
#keys값으로 2016~8년 level0 인덱스 생성 (멀티 인덱스)

result3.loc['2017년']
\#2017년 level0인덱스 기준의 5개의 행 출력

result3.loc[('2017년', 1)]
\#2017년의 1 행 출력
result3.loc[[('2016년', 1), ('2017년', 1), ('2018년', 1)], 'Symbol']
#각 연도별의 1 행의 'Symbol'열을 Series로 출력
result3.loc[[('2016년', 1), ('2017년', 1), ('2018년', 1)]]
#각 연도별의 1 행의 DataFrame 출력

result3.xs(1, level=-1, axis=0)
#dataframe.xs(조회할 index/column, level, 축방향(0:행, 1:열))
#행이나 열을 조회하는 메소드. 주로 다중 인덱스일 때 사용.
#Level은 다중인덱스의 단계를 표현한다. 바깥쪽부터 안쪽으로 0부터 1씩 증가하는 level을 가진다. (음수 index도 적용가능.)

</pre>
</code>

</br>
</br>
</br>

## join()을 통한 DataFrame 합치기
>join() - **2개 이상**의 DataFrame 조인할 때 사용
>merge() - **2개**의 DataFrame의 조인만 지원

<code>
<pre>



</pre>
</code>


</br>
</br>
</br>

## merge()을 통한 DataFrame 합치기
>조인기준 : **같은 컬럼명을 기준**으로 합친다
>조인기준을 다양하게 정할 수 있다
</br>

>DataFream.merge(합칠DataFrame, how='inner', on=None)
- on : 같은 컬럼명이 여러개 일때 join 대상 컬럼 선택
- right,left_on : 조인할 때 사용할 DataFrame의 컬럼명
- right,left_inex : 조인할 때 index를 사용할 경우 Ture로 지정
- how : 조인 방식 (right, left, outer, inner) (기본값:inner)
- suffixex : 두 DataFrame에 같은 컬럼명이 있을 경우 구분을 위해 접미어를 미리 설정


</br>

<code>
<pre>
stock_info.merge(stock_2016) 
#두 DataFrame에서 같은 컬럼명(Symbol)의 값이 같은 행끼리 join
#방식: inner join


stock_info.merge(s_2016, left_on="Symbol", right_index=True)
#왼쪽 DataFrame(stock_info)의 Symbol 컬럼과 
#오른쪽 DataFrame(s_2016)의 index name 의 값이 같은 행끼리 join


s_2018_2 = stock_2018.add_suffix('_2018')
s_2018_2.merge(stock_info, left_on='Symbol_2018', right_on='Symbol')
#s_2018_2 의 Symbol_2018 컬럼과 stock_info(right)의 Symbol 컬럼의 값이 같은 행끼리 join


stock_2016.merge(stock_2018, on="Symbol"  )
#같은 이름의 컬럼이 여러 개 있는 DataFrame들을 join할 때,
#그 중 일부 컬럼만을 기준으로 join해야 할 경우 사용된다.
#"on=join에 사용할 컬럼" 으로 지정한다. 만약 여러 개의 컬럼을 지정할 때는
#리스트나 튜플로 묶어 지정한다.


stock_2016.merge(stock_2018, on="Symbol", suffixes=['_2016', '_2018'] )
#같은 이름의 컬럼이 있을때 붙일 접미어 설정. (생략하면 _x, _y 붙인다.)
</pre>
</code>

</br>
</br>

#### 정리
- 단순한 수직 결합일 경우는 concat()을 쓰는게 편하다
- 

</br>
</br>
</br>


## 데이터 시각화의 개념 및 필요성

#### 데이터의 시각화
>데이터 분석 결과를 쉽게 이해하고 판단하기 위해 시각적으로 표현 전달 목표

</br>

#### 시각화의 필요성
- 많은 양의 데이터를 한 눈에 파악가능
- 전문적 지식이 없더라도 데이터 인지와 활용 가능
- 정확한 데이터 분석 결과를 도출할 수 있음
- 앤스컴 4분할 그래프의 예시


</br>
</br>
</br>

## 그래프 구성요소
- figure:   전체 그래프가 위치할 기본 틀, 하나의 figure에 여러 그래프를 그릴 수 있다 (게시판 같음)
- axes(subplot):figure내 그래프 그리는 공간
- axis:     축은 값을 표시하는 선, axis label(x, y)
- ticks:    축의 값을 알려주는 눈금 (Major, Minor tick)
- title:    플롯 제목
- legend:   하나의 axes내에 여러 그래프를 그린 경우 그것에 대한 설명


</br>
</br>
</br>


## pyplot 모듈을 이용해 그래프 그리기

<code>
<pre>

###하나의 그래프 그리기###
import matplotlib.pyplot as plt  
#그래프 그리기 (선그래프)
#변화를 볼 때 주로 사용 (시간, 가격 등)
plt.plot(x, y)

###그래프에 여러 설정
plt.title("그래프 제목", fontsize="25")
plt.xlabel("X축 Label")
plt.ylabel("Y축 Label")
plt.grid(True, linestyle=":")

##파일로 저장
plt.savefig("line.png")
#그래프를 화면에 출력
plt.show()



###한 figure에 여러 그래프 그리기###
#전체 figure의 크기 변경
plt.figure(figsize=(10, 5))  # (좌우너비, 상하높이) 단위: inch

#좌->우, 상->하  순번: 1부터 시작
plt.subplot(2, 2, 1)   # (2행, 2열, 첫번째 위치)
#그래프 그리고 설정.
plt.plot(x, y)
plt.scatter(x, x)   
plt.title("1번 그래프")

plt.subplot(1, 2, 2) # (1행, 2열, 두번째 위치)
plt.plot(y, x)
plt.title("2번 그래프")

plt.subplot(2, 2, 3) # (2행, 2열, 세번째 위치)
plt.scatter(x, y)
plt.title("3번 그래프")

plt.tight_layout()  #겹침 방지 (그래프 여러 개 그릴 때 써야함)
plt.show()


###하나의 axes에 여러 그래프 그리기###
#최종 출력 전에 그래프 그리는 함수들을 호출 하면 하나의 axes에 모두 그린다.
plt.plot(x, y, label="1번 선") # label: 그래프의 이름
plt.plot(y, x, label="2번 선")
plt.scatter(y, y, label="1번 점", color="green")
plt.legend() # 각 그래프의 label을 이용해서 범례를 출력

plt.show()
</pre>
</code>


</br>
</br>
</br>


## Figure와 Axes 객체를 이용해 그리기

<code>
<pre>

###Figure에 하나의 axes 그리기###
axes = plt.gca() # 그래프 그릴 Axes 객체를 생성.
print(type(axes))
#그래프 그리기, 설정 메소드 -> Axes
axes.plot(x, y)
axes.set_title("선그래프")
axes.set_xlabel("X축값")
axes.set_ylabel("Y축값")
axes.grid(linestyle=":")
plt.show()



###Figure에 여러개의 axes 그리기###
#FIGURE 객체
fig = plt.figure(figsize=(6, 6))  # figure생성
#figure에 axes(subplot)을 추가
ax1 = fig.add_subplot(2, 2, 1)
ax1.plot(x, y, label="선1")
ax1.plot(y, x, label="선2")
ax1.set_title("1번 그래프")
ax1.legend()

ax2 = fig.add_subplot(2, 2, 3)
ax2.scatter(x, y)
ax2.set_title("2번 그래프")

ax3 = fig.add_subplot(3, 2, 4)
ax3.plot(x, y, color='0.8')
ax3.set_title("3번 그래프")
plt.show()
</pre>
</code>